#region Numerical Expressions
    private Expression ParseNumericalExpression()
    {
        return ParseSum();
    }
    private bool LooksLikeNumerical()
{
    if(position< tokens.Count){
    // Comprueba si el token actual es un número o un operador numérico
    if (tokens[position].Type == TokenType.INT || tokens[position].Type == TokenType.PLUS ||
        tokens[position].Type == TokenType.MINUS || tokens[position].Type == TokenType.MULTIPLY ||
        tokens[position].Type == TokenType.DIVIDE || tokens[position].Type == TokenType.POW)
    {
        return true;
    }

    // Si comienza con un ID, verifica el siguiente token para asegurarte de que es parte de una expresión numérica
    if (tokens[position].Type == TokenType.ID && position + 1 < tokens.Count && (tokens[position + 1].Type == TokenType.PLUS ||
        tokens[position + 1].Type == TokenType.MINUS || tokens[position + 1].Type == TokenType.MULTIPLY ||
        tokens[position + 1].Type == TokenType.DIVIDE || tokens[position + 1].Type == TokenType.POW))
    {
        return true;
    }
    }

    return false;
}

    private Expression ParseSum()
    {
        var result = ParseProduct();

        while (position < tokens.Count &&
               (tokens[position].Type == TokenType.PLUS ||
                tokens[position].Type == TokenType.MINUS))
        {
            Token token = tokens[position++];
            Expression right = ParseProduct();

            result = new BinaryOperator(result, right, token.Type);
        }

        return result;
    }

    private Expression ParseProduct()
    {
        var result = ParseExponentiation();

        while (position < tokens.Count &&
               (tokens[position].Type == TokenType.MULTIPLY ||
                tokens[position].Type == TokenType.DIVIDE))
        {
            Token token = tokens[position++];
            Expression right = ParseExponentiation();

            result = new BinaryOperator(result, right, token.Type);
        }

        return result;
    }

private Expression ParseExponentiation()
{
    var result = ParsePrimaryExpression();

    while (position < tokens.Count && tokens[position].Type == TokenType.POW)
    {
        Token opToken = tokens[position++];
        Expression right = ParsePrimaryExpression(); // Asegúrate de que esto llame a ParseFactor para el operando derecho

        result = new BinaryOperator(result, right, opToken.Type);
    }

    return result;
}

private Expression ParsePrimaryExpression()
{
    if (position >= tokens.Count) throw new Exception("Unexpected end of input");

    // Comprueba si el siguiente token es un identificador
    if (tokens[position].Type == TokenType.ID)
    {
        position++; // Avanzamos al siguiente token después del identificador
        // Creamos una nueva expresión de identificador usando el token actual
        return new IdentifierExpression(tokens[position - 1]);
    }
    else if (tokens[position].Type == TokenType.MINUS && (position == 0 || tokens[position - 1].Type == TokenType.LPAREN))
    {
        // Lógica existente para manejar el caso de un operador unario -
        position++;
        Expression operand = ParsePrimaryExpression();
        return new BinaryOperator(new Number("0"), operand, tokens[position - 2].Type);
    }
    else if (tokens[position].Type == TokenType.INT)
    {
        position++;
        return new Number(tokens[position - 1].Value);
    }
    else if (tokens[position].Type == TokenType.LPAREN)
    {
        position++;
        Expression expr = ParseNumericalExpression(); // Asumiendo que ParseNumericalExpression maneja correctamente las expresiones entre paréntesis
        if (tokens[position].Type!= TokenType.RPAREN)
        {
            throw new Exception("Missing closing parenthesis");
        }
        position++;
        return expr;
    }

    throw new Exception("Invalid factor in " + position + " " + tokens[position].Value);
}
#endregion
#region Boolean Expressions


private Expression ParseOrOperation()
{
    var leftOperand = ParseAndOperation(); // Comienza parseando operaciones AND, que tienen mayor precedencia que OR

    while (LookAhead(TokenType.OR))
    {
        position++; // Avanza al siguiente token (el operador OR)
        var rightOperand = ParseAndOperation(); // Continúa parseando la expresión a la derecha del OR, buscando operaciones AND

        leftOperand = new BinaryOperator(leftOperand, rightOperand, TokenType.OR);
    }

    return leftOperand;
}

private Expression ParseAndOperation()
{
    var leftOperand = ParseNotOperation(); // Comienza parseando operaciones NOT, que tienen mayor precedencia que AND

    while (LookAhead(TokenType.AND))
    {
        position++; // Avanza al siguiente token (el operador AND)
        var rightOperand = ParseNotOperation(); // Continúa parseando la expresión a la derecha del AND

        leftOperand = new BinaryOperator(leftOperand, rightOperand, TokenType.AND);
    }

    return leftOperand;
}

private Expression ParseNotOperation()
{
    if (LookAhead(TokenType.NOT))
    {
        position++; // Avanza al siguiente token (el operador NOT)
        var operand = ParseNotOperation(); // Permite anidamiento de NOT
        return new UnaryOperator(operand, TokenType.NOT);
    }

    // Ahora, en lugar de llamar a ParseAtomic directamente, llamamos a ParseComparisonOperation
    return ParseComparisonOperation();
}

private Expression ParseComparisonOperation()
{
    var leftOperand = ParseAtomic(); // Comienza parseando expresiones atómicas, que tienen mayor precedencia que las comparaciones

    while (IsComparisonOperator(tokens[position]))
    {
        var comparisonOperator = tokens[position]; // Guarda el operador de comparación actual
        position++; // Avanza al siguiente token (el operador de comparación)
        var rightOperand = ParseAtomic(); // Continúa parseando la expresión a la derecha del operador de comparación

        leftOperand = new BinaryOperator(leftOperand, rightOperand, comparisonOperator.Type);
    }

    return leftOperand;
}
private bool IsComparisonOperator(Token token)
{
    switch (token.Type)
    {
        case TokenType.EQUAL: // ==
        case TokenType.LESS: // <
        case TokenType.MORE: // >
        case TokenType.LESS_EQ: // <=
        case TokenType.MORE_EQ: // >=
            return true;
        default:
            return false;
    }
}

private Expression ParseAtomic()
{
    if (LookAhead(TokenType.TRUE))
    {
        position++; // Avanza al siguiente token (literal booleano TRUE)
        return new BooleanLiteral(TokenType.TRUE);
    }
    else if (LookAhead(TokenType.FALSE))
    {
        position++; // Avanza al siguiente token (literal booleano FALSE)
        return new BooleanLiteral(TokenType.FALSE);
    }
    else if (LookAhead(TokenType.ID))
    {
        // Suponiendo que tienes una clase IdentifierExpression para manejar identificadores
        var identifier = tokens[position];
        position++; // Avanza al siguiente token (un identificador)
        return new IdentifierExpression(identifier);
    }
    else if (LookAhead(TokenType.LPAREN))
    {
        position++; // Avanza al siguiente token (paréntesis abierto)
        var expression = ParseExpression(); // Parsea la expresión dentro de los paréntesis
        if (!LookAhead(TokenType.RPAREN))
        {
            throw new Exception("Falta el paréntesis de cierre");
        }
        position++; // Avanza al siguiente token (paréntesis cerrado)
        return expression;
    }

    throw new Exception("Expresión atómica desconocida.");
}
#endregion
private Expression ParsePrimaryExpression()
    {
        if (position >= tokens.Count) throw new Exception("Unexpected end of input");

        // Comprueba si el siguiente token es un identificador
        if (tokens[position].Type == TokenType.ID)
        {
            position++; // Avanzamos al siguiente token después del identificador
            // Creamos una nueva expresión de identificador usando el token actual
            return new IdentifierExpression(tokens[position - 1]);
        }
        else if (tokens[position].Type == TokenType.MINUS && (position == 0 || tokens[position - 1].Type == TokenType.LPAREN))
        {
            // Lógica existente para manejar el caso de un operador unario 
            position++;
            Expression operand = ParsePrimaryExpression();
            return new BinaryOperator(new Number("0"), operand, tokens[position - 2].Type);
        }
        else if (tokens[position].Type == TokenType.INT)
        {
            position++;
            return new Number(tokens[position - 1].Value);
        }
        else if (tokens[position].Type == TokenType.LPAREN)
        {
            position++;
            Expression expr = ParseExpression(); // Asumiendo que ParseNumericalExpression maneja correctamente las expresiones entre paréntesis
            if (tokens[position].Type!= TokenType.RPAREN)
            {
                throw new Exception("Missing closing parenthesis");
            }
            position++;
            return expr;
        }

        throw new Exception("Invalid factor in " + position + " " + tokens[position].Value);
    }